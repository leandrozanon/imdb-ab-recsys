import pandas as pd
import joblib
import streamlit as st
from mlxtend.frequent_patterns import apriori, association_rules
from mlxtend.preprocessing import TransactionEncoder
from utils import show_carousel


def load_data(movies_path='./src/data/movies.csv', ratings_path='./src/data/ratings_sample.csv'):
    """
    Load movie metadata and ratings dataset.

    Args:
        movies_path (str): Path to the movies CSV file.
        ratings_path (str): Path to the ratings CSV file.

    Returns:
        movies_df (DataFrame): DataFrame with movie metadata.
        ratings_df (DataFrame): DataFrame with user ratings.
    """
    movies_df = pd.read_csv(movies_path)
    ratings_df = pd.read_csv(ratings_path)
    return movies_df, ratings_df


def create_transaction_data(ratings_df, min_ratings=4):
    """
    Convert the ratings data into a transactional format for the Apriori algorithm.

    Args:
        ratings_df (DataFrame): DataFrame with user ratings.
        min_ratings (int): Minimum number of ratings required for a movie to be included.

    Returns:
        transactions (list): List of transactions (users' movie sets).
    """
    # Filter movies that have been rated at least 'min_ratings' times
    movie_counts = ratings_df['movieId'].value_counts()
    popular_movies = movie_counts[movie_counts >= min_ratings].index
    ratings_df = ratings_df[ratings_df['movieId'].isin(popular_movies)]

    # Create transactions (userId -> set of movieIds rated by that user)
    transactions = ratings_df.groupby('userId')['movieId'].apply(list).tolist()
    return transactions

def train_apriori_model(ratings_df, min_support=0.15, min_threshold=0.35):
    """
    Train an Apriori model on the movie ratings dataset.

    Args:
        ratings_df (DataFrame): DataFrame with user ratings.
        min_support (float): Minimum support for itemsets.
        min_threshold (float): Minimum lift threshold for association rules.

    Returns:
        rules (DataFrame): DataFrame of generated association rules.
    """
    # Convert ratings to transactions (set of movies rated by each user)
    transactions = create_transaction_data(ratings_df)
    
    # Use TransactionEncoder to convert the list of transactions into one-hot encoding
    te = TransactionEncoder()
    te_ary = te.fit(transactions).transform(transactions)
    df = pd.DataFrame(te_ary, columns=te.columns_)
    
    # Apply Apriori algorithm
    frequent_itemsets = apriori(df, min_support=min_support, use_colnames=True)
    
    # Generate association rules from frequent itemsets
    rules = association_rules(frequent_itemsets, metric="lift", min_threshold=min_threshold)
    
    # Save the model to disk
    joblib.dump(rules, './src/models/model_apriori.pkl')
    
    return rules


def load_model_apriori():
    """
    Load the trained Apriori model from disk.

    Returns:
        rules (DataFrame): DataFrame of association rules.
    """
    with open("./src/models/model_apriori.pkl", "rb") as file:
        rules = joblib.load(file)
    return rules


def recommend_movies(user_id, ratings_df, movies_df, rules, n=5):
    """
    Recommend movies for a user based on association rules generated by Apriori.

    Args:
        user_id (int): ID of the user for whom to make recommendations.
        ratings_df (DataFrame): DataFrame with user ratings.
        movies_df (DataFrame): DataFrame with movie metadata.
        rules (DataFrame): Association rules generated by Apriori.
        n (int): Number of top recommendations to return.

    Returns:
        list: List of recommended movie IDs.
    """
    # Get the movies rated by the user
    user_ratings = ratings_df[ratings_df['userId'] == user_id]
    rated_movie_ids = user_ratings['movieId'].tolist()
    
    # Get the association rules that involve the rated movies
    filtered_rules = rules[rules['antecedents'].apply(lambda x: any(movie in rated_movie_ids for movie in x))]
    
    # Get the consequent movie IDs (recommended movies)
    recommended_movie_ids = set()
    for _, rule in filtered_rules.iterrows():
        recommended_movie_ids.update(rule['consequents'])

    # Exclude already rated movies from recommendations
    recommended_movie_ids.difference_update(rated_movie_ids)

    # Limit to the top N recommendations
    recommended_movie_ids = list(recommended_movie_ids)[:n]

    return recommended_movie_ids

def get_name_from_ids(movie_ids, movies_df):
    """
    Get the movie title from its ID.

    Args:
        movie_id (int): ID of the movie.
        movies_df (DataFrame): DataFrame with movie metadata.

    Returns:
        str: Title of the movie.
    """
    return movies_df[movies_df['movieId'].isin(movie_ids)]['title']

def route_b(selected_id):
    st.write("Route B: Apriori Algorithm")
    try:
        # Load pre-trained model
        rules = load_model_apriori()
        
        # Load data for prediction
        movies_df, ratings_df = load_data()
        
        # Get recommendations
        recs = recommend_movies(selected_id, ratings_df, movies_df, rules)
        recs_names = get_name_from_ids(recs, movies_df)
        
        show_carousel(recs_names)
        st.write(recs_names)


    except Exception:
        st.write("Failed to load pretrained Apriori model. Training model...")
        
        # Load data and train model
        movies_df, ratings_df = load_data()
        rules = train_apriori_model(ratings_df)
        
        st.write("Apriori model trained and loaded successfully!")
        
        # Get recommendations
        recs = recommend_movies(selected_id, ratings_df, movies_df, rules)
        recs_names = get_name_from_ids(recs, movies_df)

        show_carousel(recs_names)
        st.write(recs_names)
